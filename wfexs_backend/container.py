#!/usr/bin/env python
# -*- coding: utf-8 -*-

# SPDX-License-Identifier: Apache-2.0
# Copyright 2020-2023 Barcelona Supercomputing Center (BSC), Spain
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import absolute_import

import os
import tempfile
import atexit
import platform
import shutil
import subprocess
import abc
import logging
import inspect

from typing import (
    cast,
    TYPE_CHECKING,
)

from .common import (
    AbstractWfExSException,
)

if TYPE_CHECKING:
    from typing import (
        Mapping,
        MutableMapping,
        MutableSequence,
        Optional,
        Sequence,
        Set,
        Tuple,
        Union,
    )

    from typing_extensions import Final

    from .common import (
        AbsPath,
        AnyPath,
        Container,
        ContainerEngineVersionStr,
        ContainerFileNamingMethod,
        ContainerLocalConfig,
        ContainerOperatingSystem,
        ContainerTaggedName,
        ProcessorArchitecture,
        RelPath,
    )

from . import common


class ContainerFactoryException(AbstractWfExSException):
    """
    Exceptions fired by instances of ContainerFactory
    """

    pass


class ContainerEngineException(ContainerFactoryException):
    """
    Exceptions fired by instances of ContainerFactory when calling the
    container engine
    """

    pass


class ContainerNotFoundException(ContainerFactoryException):
    """
    Exceptions fired by instances of ContainerFactory
    when the container image or its metadata could not be found
    """

    pass


class ContainerFactory(abc.ABC):
    # Postfix of metadata files (generated by the instances)
    META_JSON_POSTFIX: "Final[str]" = "_meta.json"

    def __init__(
        self,
        cacheDir: "Optional[AnyPath]" = None,
        local_config: "Optional[ContainerLocalConfig]" = None,
        engine_name: "str" = "unset",
        tempDir: "Optional[AnyPath]" = None,
    ):
        """
        Abstract init method


        """
        if local_config is None:
            local_config = dict()
        self.local_config = local_config

        # Getting a logger focused on specific classes
        self.logger = logging.getLogger(
            dict(inspect.getmembers(self))["__module__"]
            + "::"
            + self.__class__.__name__
        )

        # cacheDir
        if cacheDir is None:
            cacheDir = local_config.get("cacheDir")
            if cacheDir:
                os.makedirs(cacheDir, exist_ok=True)
            else:
                cacheDir = cast(
                    "AbsPath", tempfile.mkdtemp(prefix="wfexs", suffix="backend")
                )
                # Assuring this temporal directory is removed at the end
                atexit.register(shutil.rmtree, cacheDir)

        if tempDir is None:
            tempDir = cast(
                "AbsPath", tempfile.mkdtemp(prefix="WfExS-container", suffix="tempdir")
            )
            # Assuring this temporal directory is removed at the end
            atexit.register(shutil.rmtree, tempDir)

        # This directory might be needed by temporary processes, like
        # image materialization in singularity or podman
        self.tempDir = tempDir
        # But, for materialized containers, we should use common directories
        # This for the containers themselves
        self.containersCacheDir = os.path.join(
            cacheDir, "containers", self.__class__.__name__
        )
        # This for the symlinks to the containers, following the engine convention
        self.engineContainersSymlinkDir = cast(
            "AbsPath", os.path.join(self.containersCacheDir, engine_name)
        )
        os.makedirs(self.engineContainersSymlinkDir, exist_ok=True)

        # This variable contains the dictionary of set up environment
        # variables needed to run the tool with the proper setup
        self._environment: "MutableMapping[str, str]" = dict()

        # This variable contains the set of optional features
        # supported by this container factory in this installation
        self._features = set()

        self.runtime_cmd = ""

        # Detecting host userns support
        host_userns_supported = False
        if os.path.lexists("/proc/self/ns/user"):
            host_userns_supported = True
            self._features.add("host_userns")
        else:
            self.logger.warning(
                "Host does not support userns (needed for encrypted working directories in several container technologies)"
            )

        self.logger.debug(f"Host supports userns: {host_userns_supported}")

    @classmethod
    @abc.abstractmethod
    def ContainerType(cls) -> "common.ContainerType":
        pass

    @classmethod
    def AcceptsContainer(cls, container: "ContainerTaggedName") -> "bool":
        return cls.AcceptsContainerType(container.type)

    @classmethod
    @abc.abstractmethod
    def AcceptsContainerType(
        cls, container_type: "Union[common.ContainerType, Set[common.ContainerType]]"
    ) -> "bool":
        pass

    @property
    def environment(self) -> "Mapping[str, str]":
        return self._environment

    @property
    def containerType(self) -> "common.ContainerType":
        return self.ContainerType()

    @property
    def command(self) -> "str":
        return self.runtime_cmd

    @property
    def cacheDir(self) -> "AbsPath":
        """
        This method returns the symlink dir instead of the cache dir
        as the entries following the naming convention of the engine
        are placed in the symlink dir
        """
        return self.engineContainersSymlinkDir

    def engine_version(self) -> "ContainerEngineVersionStr":
        """
        As most of the engines return the version with this flag,
        the default implementation is this
        """

        matEnv = dict(os.environ)
        matEnv.update(self.environment)
        with tempfile.NamedTemporaryFile() as e_err:
            with subprocess.Popen(
                [self.runtime_cmd, "--version"],
                env=matEnv,
                stdout=subprocess.PIPE,
                stderr=e_err,
            ) as sp_v:
                engine_ver: "str" = ""
                if sp_v.stdout is not None:
                    engine_ver = sp_v.stdout.read().decode("utf-8", errors="continue")
                    self.logger.debug(f"{self.runtime_cmd} version => {engine_ver}")

                d_retval = sp_v.wait()

            if d_retval == 0:
                return cast("ContainerEngineVersionStr", engine_ver.strip())
            else:
                with open(e_err.name, mode="rb") as eH:
                    d_err_v = eH.read().decode("utf-8", errors="continue")
                errstr = f"""Could not obtain version string from {self.runtime_cmd}. Retval {d_retval}
======
STDOUT
======
{engine_ver}

======
STDERR
======
{d_err_v}"""
                raise ContainerEngineException(errstr)

    @property
    def architecture(self) -> "Tuple[ContainerOperatingSystem, ProcessorArchitecture]":
        return cast("ContainerOperatingSystem", platform.system().lower()), cast(
            "ProcessorArchitecture", platform.machine()
        )

    def materializeContainers(
        self,
        tagList: "Sequence[ContainerTaggedName]",
        simpleFileNameMethod: "ContainerFileNamingMethod",
        containers_dir: "Optional[Union[RelPath, AbsPath]]" = None,
        offline: "bool" = False,
        force: "bool" = False,
    ) -> "Sequence[Container]":
        """
        It is assured the containers are materialized
        """
        materialized_containers: "MutableSequence[Container]" = []
        not_found_containers: "MutableSequence[str]" = []

        for tag in tagList:
            if self.AcceptsContainer(tag):
                container = self.materializeSingleContainer(
                    tag,
                    simpleFileNameMethod,
                    containers_dir=containers_dir,
                    offline=offline,
                    force=force,
                )
                if container is not None:
                    materialized_containers.append(container)
                else:
                    not_found_containers.append(tag.origTaggedName)

        if len(not_found_containers) > 0:
            raise ContainerNotFoundException(
                f"Could not fetch metadata for next tags because they were not found:\n{', '.join(not_found_containers)}"
            )

        return materialized_containers

    @abc.abstractmethod
    def materializeSingleContainer(
        self,
        tag: "ContainerTaggedName",
        simpleFileNameMethod: "ContainerFileNamingMethod",
        containers_dir: "Optional[Union[RelPath, AbsPath]]" = None,
        offline: "bool" = False,
        force: "bool" = False,
    ) -> "Optional[Container]":
        """
        It is assured the containers are materialized
        """
        pass

    def supportsFeature(self, feat: "str") -> "bool":
        """
        Checking whether some feature is supported by this container
        factory in this installation. Currently userns
        """
        return feat in self._features


class NoContainerFactory(ContainerFactory):
    """
    The 'no container approach', for development and local installed software
    """

    # def __init__(self, cacheDir=None, local_config=None, engine_name='unset'):
    #    super().__init__(cacheDir=cacheDir, local_config=local_config, engine_name=engine_name)
    AcceptedContainerTypes = set([common.ContainerType.NoContainer])

    @classmethod
    def ContainerType(cls) -> "common.ContainerType":
        return common.ContainerType.NoContainer

    @classmethod
    def AcceptsContainerType(
        cls, container_type: "Union[common.ContainerType, Set[common.ContainerType]]"
    ) -> "bool":
        return not cls.AcceptedContainerTypes.isdisjoint(
            container_type if isinstance(container_type, set) else (container_type,)
        )

    def engine_version(self) -> "ContainerEngineVersionStr":
        """No container engine, empty version"""
        return cast("ContainerEngineVersionStr", "")

    def materializeSingleContainer(
        self,
        tag: "ContainerTaggedName",
        simpleFileNameMethod: "ContainerFileNamingMethod",
        containers_dir: "Optional[Union[RelPath, AbsPath]]" = None,
        offline: "bool" = False,
        force: "bool" = False,
    ) -> "Optional[Container]":
        """
        This is a no-op
        """
        return None


class AbstractDockerContainerFactory(ContainerFactory):
    ACCEPTED_CONTAINER_TYPES = set(
        (
            common.ContainerType.Docker,
            common.ContainerType.UDocker,
            common.ContainerType.Podman,
        )
    )

    @classmethod
    def AcceptsContainerType(
        cls, container_type: "Union[common.ContainerType, Set[common.ContainerType]]"
    ) -> "bool":
        return not cls.ACCEPTED_CONTAINER_TYPES.isdisjoint(
            container_type if isinstance(container_type, set) else (container_type,)
        )
